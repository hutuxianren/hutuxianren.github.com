---
layout: post
comments: true
share: true
title: "操作系统"
tags: 操作系统
---

##名词解释
- 写时拷贝:只有在修改数据时才进行拷贝，是一种可以推迟甚至免除拷贝数据的技术。操作系统中使用fork()时利用写时拷贝技术，在创建子进程时不需要拷贝数据给子进程，父子进程只读共享的数据和空间，只有在数据写入时才拷贝数据。
- 内核抢占:在内核2.6版本之后，内核是可抢占式的。当一个进程在内核空间时，只要确保该进程没有持有锁，允许一个更高优先级的进程打断正在运行的进程。
- 延时写:写数据先往高速缓冲上写数据，对缓冲区设置延迟写标志，等到高速缓冲延迟满时再往磁盘上写数据。
- 系统调用:systemcall，是系统内建接口函数的集合，用于完成一些系统级别的功能。系统调用是用户到内核的转换，可用来访问硬件和其它操作系统资源。除了异常和陷入，系统调用是用户进入内核唯一合法手段。
- 内核模块:内核在需要新加入功能时，要对内核全部重新编译，为了解决这个问题，linux引入了内核模块机制。模块是一个已经编译但未连接的可执行文件，从内核角度，内核模块是一个编译好，运行时连接的文件，包含至少两个函数的代码段；从用户角度，内核模块是内核的一个插口，需要时添加，不需要时删除。
- 内核线程:独立运行在内核的标准进程，可以被调度和抢占，没有独立的地址空间，用来完成内核后台任务，且只能由内核线程创建。
- current宏:用于内核模块获取当前的进程结构体。
- proc文件系统:/proc系统是一个虚拟文件系统，它存在于内存而不是硬盘上，是内核和内核模块用来向进程发送信息的机制。该系统使得你可以和内核数据结构进行交互，获得进程有关信息，在运行时改变配置。
- 原子变量：对一个变量的操作是原子的，即不可打断的，是原子操作的基本单位。

- 上下文切换:从一个可执行进程切换到另一个可执行进程。由context_switch函数执行。完成两件事:①把虚拟内存从上一个进程映射到新的进程中②从上一个进程的处理器状态切换到新进程的处理器状态，包括保存寄存器等信息。
- 进程时间片:进程在被强占前所能持续运行的时间。预加载调度:200ms,还能根据进程优先级动态调整时间片。
- 中断机制:当硬件处理I/O时,cpu不必马上对它进行处理，而是由中断机制去处理，等硬件完全完成请求后，再通知内核回头来处理。
- 触发软中断:一个__注册的__软中断必须被标记后才能执行，通常中断处理程序会在返回前标记它的软中断。
- 临界区:访问和操作共享数据的代码段，整个临界区是个不可分割的指令。
- 竞争条件:多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关。
- 同步:避免并发和防止竞争条件称为同步。
- 争用:锁的争用，当线程持有锁时，其它线程试图获得锁。
- 死锁:每个线程都在等待其它线程释放资源，但这些资源都被占有，且各个进程永远不放弃，于是任何线程都无法继续，这就是死锁。
- 屏障:确保顺序要求的机器指令，所有可能重新排序和写的处理器提供了机器指令来确保顺序要求，同时指示编译器不对给定点周围的指令序列进行重新排序。
- 软实时:内核调度进程，尽量使它在限定时间内运行，但内核不保证总能满足进程要求。 举例:软实时系统的时限是一个柔性灵活的，它可以容忍偶然的超时错误。失败造成的后果并不严重，仅仅是轻微的降低了系统的吞吐量。如播放DVD成功率98%就可以接受。
- 索引节点:一种数据结构，保存文件对象的元信息，但不包含数据。

##简答题
- 进程控制块的处理,linux和unix有何区别，有何好处?  
    早期的unix使用prog和user处理进程控制块
    - prog存储控制块最常用最必须的信息，所以常驻内存
    - user存放只有在运行时才用到的数据，在处理器不运行时，将其放在硬盘的对换区,节省主存。  
  而Linux使用slab分配器动态分配进程描述符task_struct，对象和缓存
  造成这种区别的原因是内存的限制，早期的unix内存小，分部处理节省了内存，而现在内存有了显著提升，linux的处理方式更加高效。
  
  
- 为什么分上下部，简述tasklet思想，下半部的方法有哪些？
  中断服务程序异步执行，可能会中断其它代码，为了避免代码延迟太长，中断程序要尽快运行，且执行时间越短越好。所以中断程序只做必须做的工作，其它任务随后执行。故将中断分为上下部，上部是中断处理程序，对时间要求严格的任务在这上面执行，剩下的可以延后的任务在下半部处理，这样提高了系统响应能力，实现了程序运行快完成工作量多得目标。
  tasklet:中断下半部可使用tasklet实现，它基于软中断，task内部对软中断进行封装，具有以下特性:
  ①一种特定类型的tasklet只能运行在一个cpu上，不能并行，只能串行②多个不同类型的可以运行在多个cpu上③软中断是静态分配的，编译好不能改变而tasklet可运行时改变。
  taklet在HI_SOFTIRQ和tasklet_IRQ两种实现的，如果不需要软中断的并行性，tasklet是最好的选择。  
  下半部有三种方法:软中断、tasklet和工作队列。软中断适用于对并行性好、性能高的情况；tasket用于对并行性要求不那么高的程序，尽量选择tasklet.如果中断延期工作需要在进程上下文中运行，工作队列是唯一的选择。
 
- 进程和线程的区别,linux是如何实现线程?  
  进程是执行代码和资源的总称，而线程是进程对象。进程是资源管理的最小对象，而线程是程序执行的最小单位，内核调度的对象是线程而不是进程。为了支持smp和减少上下文的开销而使用线程，一个进程至少需要一个线程作为执行体。smp可使用多cpu执行各个线程，达到最大程度并行。  
  linux线程实现:内核把线程当做进程实现，它被视为和其它进程共享资源的一个进程，拥有自己的程序计数器等，也和进程一样拥有唯一的task_struct.
 
- 进程的状态  
  - task_running:可执行状态
  - task_interruptible:可中断的睡眠
  - task_uninterruptible:不可中断的睡眠
  - task_stopped or task_traced:暂停或跟踪状态
  - task_dead-Exit_Zombie:退出执行,成为僵尸进程
  - task_dead-Exit_Dead:退出状态,进程即将销毁
  
- 内核锁有哪些?为何要多个锁?  
  内核锁:原子操作、自旋锁、信号量、大内核锁、顺序锁
  因为维护锁的环境不同、开销不同、等待时间不同、是否允许睡眠也不同，所以要设计多种锁机制来应对各种情况。原子操作保证指令执行过程不被打断，自旋锁适用于时间较短、不需睡眠的情况；信号量适用于等待时间较长、需要睡眠的情况。大内核锁是一种递归锁，不会死锁；顺序锁适用于读写共享数据、轻量级的情况。
- 举例说明内核的某一块设计是利用面向对象技术的  
面向对象特性有三:封装、继承、多态。封装是把方法和属性包装起来，实现信息隐蔽；继承是指对象直接用另一个对象的性质和方法；而多态是指接口的多种不同实现。  
举例：①封装:文件系统的file对象只定义了方法的原型而没有具体方法，具体实现由操作系统提供；内核中重要数据结构进行了封装，如文件系统的Inode对象，内存管理中的page、slab和cache对象。
②继承:内核中的通用链表结构可看做一个基类，而其他链表结构可看做它的子类。
③多态性:虚拟文件系统可看做抽象基类，ext2、ext3、VFAT可看做子类。

- 内核开发的特点
   - 不能访问标准c库，连最常见的printf函数也不行。
   - 必须使用GNU C
   - 没有内存保护机制，内核中的内存不分页
   - 尽量不去操作浮点数
   - 内核栈容积小且固定
   - 同步机制，防止竞争条件
   - 注重可移植性

- 进程上下文和中断上下文以及区别:进程上下文是指进程切换到另一个进程时保存当前进程的所有状态，以便再次执行该进程时，能恢复切换时的状态。而中断上下文是中断时保存的中断信息，在内核态执行中断服务，同时保留所有需要用到的资源，以便中断服务结束时能恢复被中断进程的执行。它们两者本身没有关系，进程上下文可以睡眠而中断上下文不可睡眠。进程上下文可以通过current宏关联到当前进程，而中断上下文和进程没什么关系，与current宏也毫不相关，尽管它会指向被中断的进程。
- linux如何实现o(1)调度  
  2.6内核改进了可扩展性问题，schedule函数时间复杂度为o(1),这取决于两个改进:①pick next算法借助active数组，无需遍历runqueue.②取消了定时更新所有进程counter的操作，动态优先级的修改分布在进程切换，时钟tick中断以及其他内核函数中。
- 系统调用和c库的作用及其关系  
   - 用户使用系统提供的服务的途径即是系统调用。它是用户程序和内核交界处系统提供的调用接口，扮演中间人的角色。系统调用处理用户发出的信息，再将处理结果返回到用户程序。
   - c库包含操作系统绝大数满足posix的api，内核提供的每个系统调用在c库中都有对应的封装函数。c库中系统调用函数封装在调用到系统调用时，不会有太多的工作。他两并不是一一对应的关系，可能几个不同函数会调用到同一个系统调用，也有可能一个函数调用到多个系统调用。
   - 从用户角度，只需关心通过c库函数实现的功能；从内核角度，考虑的是提供哪些功能的系统调用，不关心如何被使用。